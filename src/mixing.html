<section>
 <h2 id="mixing">Annotating MathML</h2>
 <!-- <div class="issue" data-number="281"></div>-->
 <!-- <div class="issue" data-number="252"></div>-->

 <!--<div class="issue" data-number="289"></div>-->
 <p class="issue" data-number="257">Issue 257</p>
 <p class="issue" data-number="255">Issue 255</p>
 <p class="issue" data-number="254">Issue 254</p>
 <p class="issue" data-number="253">Issue 253</p>

 <p>Annotation refers to markup added to
 make associations between alternate representations of an expression.
 Multiple annotations can be associated with each other using the
 <code class="element">semantics</code> element.
 Two important representations that can be associated with each other are
 presentation markup and content markup. Other uses of <code class="element">semantics</code>
 include associating the original source representation of an expression with presentation or content MathML.
 <a href="#mixing_annotation_elements"></a> describes the <code class="element">semantics</code> element.
</p>

<p>MathML has been widely adopted by assistive technologies (AT).
  However, math notations can be ambiguous which can result in AT guessing at what should be spoken in some cases.
  MathML 4 adds a lightweight method for authors to express their intent: the <code class="attribute">intent</code> attribute.
  This attribute is similar to the <a href="https://www.w3.org/TR/wai-aria-1.1/#aria-label"><code class="attribute">aria-label</code></a> attribute
  with some important distinctions.
  In terms of accessibility, the major difference is that <code class="attribute">intent</code>
  does <em>not</em> affect braille generation.
  Most languages have a separate braille code for math so that the words used for speech should not be affected by braille generation.
  Some languages, such as English, have more than one braille math code and it is impossible for the author to know which is desired by the reader.
  Hence, even if the author knew the (math) braille for the element, they could not override <code class="attribute">aria-label</code>
  by using the proposed <a href="https://w3c.github.io/aria/#aria-braillelabel">aria-braillelabel</a> because they wouldn't know which code to use.
 </p>

 <section>
  <h3 id="mixing_intent">The <code class="attribute">intent</code> attribute</h3>
  <p>As described in <a href="#fund_globatt"></a>,
  MathML elements allow attributes <code
  class="attribute">intent</code> and <code
  class="attribute">arg</code> that allow the
  <dfn><q>intent</q></dfn> of the term to be specified. This
  annotation is not meant to provide a full mathematical definition
  of the term. It is primarily meant to help AT generate audio and/or braille renderings, see <a href="#accessibility"></a>.
  Nevertheless, it may also be useful to guide translations to Content MathML, or computational systems.</p>

  <p>The <code class="attribute">intent</code> attribute encodes a
  simple functional syntax representing the intended speech.
  A formal grammar is given below, but a typical example would be
  <code>intent="power($base,$exponent)"</code> used in a context such as:</p>

  <div class="example mathml mmlcore">
   <pre>
    &lt;msup intent="power($base,$exp)">
      &lt;mi arg="base">x&lt;/mi>
      &lt;mi arg="exp">n&lt;/mi>
    &lt;/msup>
   </pre>
  </div>
  <p>The <code class="attribute">intent</code> value of <code>power($base,$exp)</code> makes it clear that the author intends that this expression
    denotes exponentiation as opposed to one of many other meanings of superscripts.
    Since power will be a concept known to the AT, it may choose different
    ways of speaking depending on context, arguments or other details.
    For example, the above expression might be spoken as "x to the power n",
    but if "2" were given instead of "n", it may say "x squared".</p>

  <section>
   <h4 id="mixing_intent_grammar">The Grammar for <code class="attribue">intent</code></h4>

   <p>The value of the <code class="attribute">intent</code> attribute, after ignoring white
   space between tokens, should match the following grammar.</p>

   <pre class="def bnf">
intent             := term property* hint? | property+ hint? | application 
term               := concept-or-literal | number | reference 
concept-or-literal := NCName
number             := '-'? digit+ ( '.' digit+ )?
reference          := '$' NCName
application        := intent S '(' S arguments? S ')'
arguments          := intent ( S ',' S intent )*
property           := S ':' S NCName
hint               := S '@' S ( 'prefix' | 'infix' | 'postfix' | 'function' | 'silent' )
S                  : [ \t\n\r]*
   </pre>

   <p>Here <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName"><code>NCName</code></a>
   is as defined in  in [[xml-names]], and <code>digit</code> is a character in the range 0–9.</p>


   <p>The parts consist of:</p>
   <dl>
    <dt><dfn id="intent_concept-or-literal">concept-or-literal</dfn></dt>
    <dd>Names should match the <code>NCName</code> production as used for
    no-namespace element name.
    A [=concept-or-literal=] are interpreted either as a [=concept=] or [=literal=].
    <ul>
     <li>
      <p>A <dfn id="intent_concept">concept</dfn> corresponds to some mathematical or
      application specific function or concept.
      For many concepts, the words used to speak a concept are very similar to the name
      used when referencing a concept.
      A [=concept=] matches a name in an [=Intent Concept Dictionary=] recognized by the AT,
      to produce specific audio or braille renderings based on the speech hints
      given in the dictionary.</p>
    </li>
    <li>
      <p>A <dfn id="intent_literal">literal</dfn> is a name that does not match a [=concept=]
      name known to the application.  In this case, a default reading is generated by replacing any
      <code>-</code>, <code>_</code>, <code>.</code> in the name by
      spaces and then reading the resulting phrase.
      Names starting with <q>`_`</q> (U+00F5)  are always considered to be [=literal=] names,
      and should never be in an [=Intent Concept Dictionary=].</p>
     </li>
    </ul>
    </dd>
    <dt><dfn data-dfn-for="intent" id="intent_number">number</dfn></dt>
    <dd>
     A literal <a data-link-for="intent" data-link-type="dfn" href="#intent_number">number</a> such as <code>2.5</code> denotes itself.
    </dd>

    <dt><dfn id="intent_reference">reference</dfn></dt>
    <dd>
    An argument [=reference=] such as <code>$name</code> refers to a descendent element
    that has an attribute <code>arg="name"</code>. Unlike <code class="attribute">id</code>
    attributes, <code class="attribute">arg</code> do not have to be
    unique within a document. When searching for a matching element the
    search should only consider descendants, while stopping early at any
    elements that have a set <code class="attribute">intent</code> or
    <code class="attribute">arg</code> attribute, without descending
    into them.
    Proper use of [=reference=], instead of inserting equivalent literals,
    allows intent to be used while navigating the mathematical structure.
    </dd>

    <dt><dfn data-dfn-for="intent" id="intent_application">application</dfn></dt>
    <dd>
     An <a data-link-for="intent" data-link-type="dfn" href="#intent_application">application</a>
     denotes a function applied to arguments using
     a standard prefix notation.  Optionally, between the head of the
     function and the list of arguments there may be a [=hint=] as
     described below to influence the style of text reading generated.
    </dd>

    <dt><dfn id="intent_hint">hint</dfn></dt>
    <dd>
     A [=hint=] in a function <a data-link-for="intent" data-link-type="dfn"
     href="#intent_application">application</a> requests that
     the reading of the name may be suppressed, or the word ordering may be affected.
     Note that the hints <code>prefix</code>, <code>infix</code> and <code>postfix</code>
     refer to the spoken word order of the name and arguments,
     and <em>not</em> (necessarily) the order used in the displayed mathematical notation.
     <ul>
      <li>
      In the case of a [=concept=] name, the hint MAY be used in choosing the alternatives
      supported by the AT. For example <code>union</code> is in the
      Core dictionary with speech patterns "$1 union $2" and "union of $1 and $2".
      An intent <code>union @prefix ($a,$b)</code> would
      indicate that the latter style is preferred.
      </li>
      <li>For [=literal=] names, the text generated from the function head SHOULD be read
      as specified in the hint.
     <ul>
      <li><code>f @prefix ($x)      </code>: <q>f x</q></li>
      <li><code>f @infix ($x,y)     </code>: <q>x f y</q></li>
      <li><code>f @postix ($x)      </code>: <q>x f</q></li>
      <li><code>f @function ($x, $y)</code>: <q>f of x and y</q></li>
      <li><code>f @silent ($x,$y)   </code>: <q>x y</q></li>
     </ul>
      The specific words used above are only examples;
      AT is free to choose other appropriate audio renderings.
      For example, <code>f@function($x, $y)</code> could also be spoken as
      <q>f of x comma y</q>.
      </li>
     </ul>
    </dd>
    <dt><dfn id="intent_hint">property</dfn></dt>
    <dd>
     A [=property=] annotates the concept name with additional
     properties such as `:unit` or `:chemistry` which may be used by
     the system to adjust the generated speech or Braille in system
     specifc ways.
    </dd>
   </dl>
  </section>

  <section>
    <h4 id="mixing_intent_dictionaries">Intent Concept Dictionaries</h4>
     <p>An <dfn>Intent Concept Dictionary</dfn> is a mapping from a [=concept=] name
      to specific speech or braille for that concept.
      The mapping may take into account any [=hint=] that follows the name.
      AT that makes use of <code class="attribute">intent</code>
      SHOULD be able to produce speech or braille that corresponds to any
      of the concepts in the [=Core=] table discussed below.
      AT that makes use of <code class="attribute">intent</code>
       MAY also include concepts in the [=Open=] table discussed below,
       as well as its own built-in dictionaries.
      </p>
      <p>The Intent Concept Dictionary is somewhat analogous to the <a href="#oper-dict"></a> used by
      MathML renderers in that it provides a set of defaults renderers should be aware of.
      The <code>hint</code> also has some analogies to the operator dictionary's use of
      <code class="attribute">form</code>.
    </p>
    <p class="issue" data-number="410">Issue 410</p>
    <p>
     [=Intent=] identifiers are maintained in two lists,
     currently located at <a
     href="https://docs.google.com/spreadsheets/d/1EsWou1K5nxBdLPvQapdoA9h-s8lg_qjn8fJH64g9izQ/edit#gid=1358098730">Google Sheets</a>.
    </p>

     <ul>
      <li>
       <dfn id="intent-core">Core</dfn>: This is a list of core
      concept names curated by the Math Working Group.
      This list includes common concepts such as <q>divide</q>, <q>power</q>, and <q>greater-than</q>.
      AT reading MathML attributed with a name in this list SHOULD consider this name to be a hint how the content could be read.
      However, because common notations have many specialized ways of being spoken
      (e.g., for division, one might say <q>three quarters</q>, <q>x over three</q>, or <q>3 meters per second</q> depending
      one the contents of <code>&lt;mfrac intent="divide($num,$denom)&gt;</code>),
      AT is not constrained to use the name given.
      Depending upon the reader, AT may add words or sounds to make the speech clearer to the listener.
      For example, for someone who can not see the a fraction, AT might say <q>fraction x over three end fraction</q> so the listener
      knows exactly what is part of the fraction.
      For someone who can see the content, these extra words can be a distraction.
      AT should always produce speech that is appropriate to the community they serve.</li>
      <li><dfn id="intent-open">Open</dfn>: This is an open list of concepts
      to which contributions are invited.
      AT reading MathML attributed with a name in this list
      MAY use the speech hints provided by the intent
      definition but a system
      may also fall back on reading the identifier name as given.
      Although authors are encouraged to use a name in this list that matches their intent if one exists,
      any string that is an <code>NCName</code> is allowed.
      </li>
     </ul>
     <p>Future versions of the concept list may incorporate names from the <q>open</q> list into the
      <q>core</q> list if usage indicates that is appropriate.
     </p>
     <p>When comparing the literal concept name in the <code
     class="attribute">intent</code> attribute with entries in the intent
     lists, the comparison should be
     <a data-cite="INFRA#ascii-case-insensitive">ASCII case-insensitive</a>
     and also normalize
     <q>`_`</q> (U+00F5) and <q>`.`</q>  (U+002E) to <q>`-`</q> (U+002D).
     If the speech hints are not being used
     and the literal concept name is being read then each of  `-`, `_` and `.` should be
     read as an inter-word space.</p>
  </section>

  <section>
   <h4 id="mixing_intent_errors">Intent Error Handling</h4>
   <p>An intent processor may report errors in intent expressions in
   any appropriate way, including returning a message as the
   generated text, or throwing an exception (error) in whatever form
   the implementation supports. However in  web platform context it is
   often not appropriate to report errors to the readers who have no
   access to correct the source, so intent procesors should offer a
   mode which recovers from errors as described below.</p>
   <section>
    <h5 id="mixing_intent_error_recovery">Intent Error Recovery</h5>
    <ol>
     <li>If an <code class="attribute">intent</code>
     attribute does not match the grammar <a href="#mixing_intent_grammar"></a>,
     then the processor should act as if the attribute were not
     present.
     Typically this will result in a suitable fallback text being
     generated from the MathML element and its descendents. Note that
     just the erroneous attribute is ignored, other <code
     class="attribute">intent</code> attributes in the MathML
     expression should be used.</li>
     <li>If a `reference` such as `$x` does not correspond to an <code
     class="attribute">arg</code> attribute with value `x` on a
     descendent element, the processor should act as if the reference
     were replaced by the literal `_dollar_x`.</li>
    </ol>
   </section>
  </section>
    
  <section>
   <h4 id="mixing_intent_examples">Intent Examples</h4>

    <p>A primary use for <code class="attribute">intent</code> is to
    disambiguate cases where the same syntax is used for different meanings,
    and typically has different readings.</p>

    <p>Superscript, <code class="element">msup</code>, may represent a power, a transpose,
    a derivative or an embellished symbol. These cases would be distinguished as follows, showing possible readings <em>with</em> and <em>without</em> <code class="attribute">intent</code></p>

<div class="example mathml mmlcore">
<pre>
&lt;msup intent="power($base,$exp)">
  &lt;mi arg="base">x&lt;/mi>
  &lt;mi arg="exp">n&lt;/mi>
&lt;/msup>
</pre>
<blockquote>x to the n-th power<br/> x superscript n end superscript</blockquote>
</div>
<p>An alternative default rendering without intent would be to assume that
  <code class="element">msup</code> is always a power, so the second rendering above
  might also be <q>x to the n-th power</q>. In that case the second renderings below
  will (incorrectly) speak the examples using <q>raised to the ... power</q>.
</p>
<div class="example mathml mmlcore">
<pre>
&lt;msup intent="$op($a)">
  &lt;mi arg="a">A&lt;/mi>
  &lt;mi arg="op" intent="transpose">T&lt;/mi>
&lt;/msup>
</pre>
<blockquote>transpose of A<br/> A superscript T end superscript </blockquote>
</div>
<p>However, with a hint, this example might be read differently.</p>
<div class="example mathml mmlcore">
<pre>
&lt;msup intent="$op @postfix ($a)">
  &lt;mi arg="a">A&lt;/mi>
  &lt;mi arg="op" intent="transpose">T&lt;/mi>
&lt;/msup>
</pre>
<blockquote>A transpose</blockquote>
</div>

<div class="example mathml mmlcore">
<pre>
&lt;msup intent="derivative($a)">
  &lt;mi arg="a">f&lt;/mi>
  &lt;mi>&#x2032;&lt;/mi>
&lt;/msup>
</pre>
<blockquote>derivative of f<br/> f superscript prime end superscript</blockquote>
</div>
<div class="example mathml mmlcore">
<pre>
&lt;msup intent="x-prime">
  &lt;mi>x&lt;/mi>
  &lt;mo>&#x2032;&lt;/mo>
&lt;/msup>
</pre>
<blockquote>x prime<br/> x superscript prime end superscript</blockquote>
</div>

<p>Custom accessible descriptions, such as author-preferred variable or operator names, can also be annotated compositionally, via the underscore function.</p>
<p>The above notation could instead intend the custom name "x-new", which we can mark with a single literal `intent="x-new"`, or as a compound narration of two arguments:</p>
<div class="example mathml mmlcore">
<pre>
&lt;msup intent="_($base,$script)">
  &lt;mi arg="base">x&lt;/mi>
  &lt;mo arg="script" intent="_new">&#x2032;&lt;/mo>
&lt;/msup>
</pre>
<blockquote>x new<br/>x superscript prime end superscript</blockquote>
</div>

<p>Using the underscore function may also add clarity when the fragments of a compound name are explicitly localized. A cyrillic (Bulgarian) example:</p>
<div class="example mathml mmlcore">
<pre>
&lt;msup intent="_($base,$script)">
  &lt;mi arg="base" intent="_хикс">x&lt;/mi>
  &lt;mo arg="script" intent="_прим">&#x2032;&lt;/mo>
&lt;/msup>
</pre>
<blockquote>хикс прим<br/>x superscript prime end superscript</blockquote>
</div>

<p>Alternatively, the narration of individual fragments could be fully delegated to AT, while still specifying their grouping:</p>
<div class="example mathml mmlcore">
<pre>
&lt;msup intent="_($base,$script)">
  &lt;mi arg="base">x&lt;/mi>
  &lt;mo arg="script">&#x2032;&lt;/mo>
&lt;/msup>
</pre>
</div>

    <p>An overbar may represent complex conjugation, or mean (average), again with possible readings with and without <code class="attribute">intent</code>:</p>

 <div class="example mathml mmlcore">
<pre>
&lt;mover intent="conjugate($v)"&gt;
  &lt;mi arg="v"&gt;z&lt;/mi&gt;
  &lt;mo&gt;&amp;#xaf;&lt;/mo&gt;
&lt;/mover&gt;
&lt;mtext>&amp;#x00A0;&lt;!--nbsp--&gt;is not&amp;#x00A0;&lt;!--nbsp--&gt;&lt;/mtext>
&lt;mover intent="mean($var)"&gt;
  &lt;mi arg="var"&gt;X&lt;/mi&gt;
  &lt;mo&gt;&amp;#xaf;&lt;/mo&gt;
&lt;/mover&gt;
</pre>

     <blockquote>conjugate of z is not  mean of X<br/>
     z with bar above  is not  X with bar above</blockquote>
    </div>

    <p>The intent mechanism is extensible through the use of [=literal=] names.
      For example, assuming that the Bell Number is not present in any the dictionaries,
      the following example</p>
    <div class="example mathml mmlcore">
<pre>
&lt;msub intent="bell-number($index)"&gt;
  &lt;mi&gt;B&lt;/mi&gt;
  &lt;mn arg="index"&gt;2&lt;/mn&gt;
&lt;/msub&gt;
</pre>
     <p>will still produce the expected reading:</p>
     <blockquote>bell number of 2</blockquote>
    </div>
   </section>

   <section>
    <h4 id="mixing_intent_warning">A Warning about [=literal=] and [=hint=]</h4>
    <p>The [=literal=] and [=hint=] features extend the coverage of mathematical concepts
    beyond the predefined dictionaries and allow expression of speech preferences.
    For example, when `$x` and `$y` reference `&lt;mi arg="x">x&lt;/mi>` and `&lt;mi
     arg="y">y&lt;/mi>` respectively, then</p>
    <ul>
     <li><code>list @silent ($x,$y)</code> would be read as <q>x y</q></li>
     <li><code>semi-factorial @postfix($x)</code> would be read as <q>x semi factorial</q></li>
    </ul>
    <p>These features also allow taking almost complete control of the generated speech.
    For example, compare:</p>
    <ul>
     <li><code>free-algebra ($r, $x)</code><br/>
     would be read as <q>free algebra of r and x</q></li>

     <li><code>free-algebra-construct@silent (_free, $r, _algebra, _on, $x)</code><br/>
      would be read as <q>free r algebra on x</q></li>

      <li><code>_(free, _($r,algebra), on, $x)</code><br/>
      would be read as <q>free r algebra; on x</q></li>
    </ul>
    <p>However, since the literals are not in dictionaries,
     the meaning behind the expressions become more opaque,
     and thus excessive use of these features will tend to limit the AT's ability
     to adapt to the needs of the user, as well as limit translation and locale-specific speech.
     Thus, the last two examples would be discouraged.
    </p>
   </section>

   <section>
     <h4 id="mixing_intent_examples_mtr">Tables</h4>
     <div class="ednote">
       <p>The <code class="element">&lt;mtable&gt;</code> element is
       used in many ways, for denoting matrices, systems of equations,
       steps in a proof derivation, etc. In addition to these uses it
       may be used to implement forced line breaking and alignment,
       especially for systems that do not implement
       [[[#presm_linebreaking]]], or for conversions from (La)TeX where
       alignment constructs are used in similar ways.</p>
       <p>Some examples are given below, and the Working Group plans to
       propose recommended uses of [=intent=] to address these use
       cases. This may require some small extensions to the intent
       grammar or to the terms in the Core Concept dictionary of intent
       terms. Discussions are taking place in the following two GitHub
       Issues.</p>

     </div>

       <p class="issue" data-number="337">Issue 337</p>
       <p class="issue" data-number="402">Issue 402</p>


<p>Matrices</p>
<div class="example mathml mmlcore">
<pre>
&lt;mrow>
  &lt;mo>(&lt;/mo>
  &lt;mtable>
    &lt;mtr>
      &lt;mtd>&lt;mn>1&lt;/mn>&lt;/mtd>
      &lt;mtd>&lt;mn>0&lt;/mn>&lt;/mtd>
    &lt;/mtr>
    &lt;mtr>
      &lt;mtd>&lt;mn>0&lt;/mn>&lt;/mtd>
      &lt;mtd>&lt;mn>1&lt;/mn>&lt;/mtd>
    &lt;/mtr>
  &lt;/mtable>
  &lt;mo>)&lt;/mo>
&lt;/mrow>
</pre>
    </div>


    <p>Aligned equations</p>
    <div class="example mathml mmlcore">
<pre>
&lt;mtable>
  &lt;mtr>
    &lt;mtd columnalign="right">
      &lt;mn>2&lt;/mn>
      &lt;mo>&amp;#x2062;&lt;!--InvisibleTimes--&gt;&lt;/mo>
      &lt;mi>x&lt;/mi>
    &lt;/mtd>
    &lt;mtd columnalign="center">
      &lt;mo>=&lt;/mo>
    &lt;/mtd>
    &lt;mtd columnalign="left">
      &lt;mn>1&lt;/mn>
    &lt;/mtd>
  &lt;/mtr>
  &lt;mtr>
    &lt;mtd columnalign="right">
      &lt;mi>y&lt;/mi>
    &lt;/mtd>
    &lt;mtd columnalign="center">
      &lt;mo>&gt;&lt;/mo>
    &lt;/mtd>
    &lt;mtd columnalign="left">
      &lt;mi>x&lt;/mi>
      &lt;mo>-&lt;/mo>
      &lt;mn>3&lt;/mn>
    &lt;/mtd>
  &lt;/mtr>
&lt;/mtable>
</pre>
    </div>

    <p>Aligned Equations with wrapped expressions</p>

    <div class="example mathml mmlcore">
<pre>
&lt;mtable>
  &lt;mtr>
    &lt;mtd columnalign="right">
      &lt;mi>a&lt;/mi>
    &lt;/mtd>
    &lt;mtd columnalign="center">
      &lt;mo>=&lt;/mo>
    &lt;/mtd>
    &lt;mtd columnalign="left">
      &lt;mi>b&lt;/mi>
      &lt;mo>+&lt;/mo>
      &lt;mi>c&lt;/mi>
      &lt;mo>-&lt;/mo>
      &lt;mi>d&lt;/mi>
    &lt;/mtd>
  &lt;/mtr>
  &lt;mtr>
    &lt;mtd columnalign="right">&lt;/mtd>
    &lt;mtd columnalign="center">&lt;/mtd>
    &lt;mtd columnalign="left">
      &lt;mo form="infix">+&lt;/mo>
      &lt;mi>e&lt;/mi>
      &lt;mo>-&lt;/mo>
      &lt;mi>f&lt;/mi>
    &lt;/mtd>
  &lt;/mtr>
&lt;/mtable>
</pre>
    </div>
   </section>

 </section>

 <section>
  <h3 id="mixing_annotation_elements">Annotation Elements</h3>

  <p>
   In addition to the <code class="attribute">intent</code> attribute described above,
   MathML provides a more general framework for annotation.  A MathML expression may be
   decorated with a sequence of pairs made up of a symbol that indicates
   the kind of annotation, known as the <em>annotation key</em>, and
   associated data, known as the <em>annotation value</em>.
  </p>


  <p>
   The <code class="element">semantics</code>, <code class="element">annotation</code>, and
   <code class="element">annotation-xml</code> elements are used together to represent
   annotations in MathML.  The <code class="element">semantics</code> element provides the
   container for an expression and its annotations.  The
   <code class="element">annotation</code> element is the container for text
   annotations, and the <code class="element">annotation-xml</code> element is used for
   structured
   annotations. The <code class="element">semantics</code> element contains the expression
   being annotated as its first child, followed by a sequence of zero or
   more <code class="element">annotation</code> and/or <code class="element">annotation-xml</code> elements.
  </p>

  <p>The <code class="element">semantics</code> element is considered
  to be both a presentation element and a content element, and may be
  used in either context.  All MathML processors should process the
  <code class="element">semantics</code> element, even if they only
  process one of these two subsets of MathML, or
  [[MathML-Core]].
  </p>


  <section>
   <h4 id="mixing_annotation_keys">Annotation keys</h4>

   <p>An <em>annotation key</em> specifies the relationship between an
   expression and an annotation. Many kinds of relationships are possible.
   Examples include alternate representations, specification or clarification
   of semantics, type information, rendering hints, and private data
   intended for specific processors.  The annotation key is the primary
   means by which a processor determines whether or not to process an
   annotation.</p>

   <p>The logical relationship between an expression and an annotation
   can have a significant impact on the proper processing of the
   expression.  For example, a particular annotation form, called <em>semantic
   attributions</em>, cannot be ignored without altering the meaning
   of the annotated expression, at
   least in some processing contexts. On the other hand, alternate
   representations do not alter the meaning of an expression, but may
   alter the presentation of the expression as they are frequently used
   to provide rendering hints.  Still other annotations carry private data or
   metadata that are useful in a specific context, but do not alter either
   the semantics or the presentation of the expression.</p>

   <p>Annotation keys may be defined as a symbol in a <a class="intref" href="#contm_cds">Content Dictionary</a>, and are specified using
   the <code class="attribute">cd</code> and <code class="attribute">name</code> attributes on the
   <code class="element">annotation</code> and <code class="element">annotation-xml</code> elements.
   Alternatively, an annotation key may also be referenced
   using the <code class="attribute">definitionURL</code> attribute as an alternative to the
   <code class="attribute">cd</code> and <code class="attribute">name</code> attributes.
   </p>

   <p>MathML provides two predefined annotation keys for the most common
   kinds of annotations: <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#alternate-representation">alternate-representation</a> and <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#contentequiv">contentequiv</a> defined in the <a class="omcd" href="https://openmath.org/cd/mathmlkeys">mathmlkeys</a> content
   dictionary. The <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#alternate-representation">alternate-representation</a> annotation key specifies that the
   annotation value provides an alternate representation for an
   expression in some other markup language, and the <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#contentequiv">contentequiv</a> annotation key specifies that
   the annotation value provides a semantically equivalent alternative
   for the annotated expression.</p>

   <p>The default annotation key is <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#alternate-representation">alternate-representation</a> when no annotation key is
   explicitly specified on an <code class="element">annotation</code> or
   <code class="element">annotation-xml</code> element.</p>

   <p>Typically, annotation keys specify only the logical nature of the
   relationship between an expression and an annotation.  The data format
   for an annotation is indicated with the <code class="attribute">encoding</code>
   attribute.  In MathML 2, the <code class="attribute">encoding</code> attribute was the
   primary information that a processor could use to determine whether or
   not it could understand an annotation.  For backward compatibility,
   processors are encouraged to examine both the annotation key and
   <code class="attribute">encoding</code> attribute.  In
   particular, MathML 2 specified the predefined encoding values
   <code>MathML</code>, <code>MathML-Content</code>, and
   <code>MathML-Presentation</code>.  The <code>MathML</code> encoding
   value is used to indicate an <code class="element">annotation-xml</code> element contains
   a MathML expression.  The use of the other values is more specific, as
   discussed in following sections.</p>

  </section>

  <section>
   <h4 id="mixing_alternate_representations">Alternate representations</h4>

   <p>Alternate representation annotations are most often used to
   provide renderings for an expression, or to provide an equivalent
   representation in another markup language.  In general, alternate
   representation annotations do not alter the meaning of the annotated
   expression, but may alter its presentation.</p>

   <p>A particularly important case is the use of a presentation MathML
   expression to indicate a preferred rendering for a content MathML
   expression.  This case may be represented by labeling the annotation
   with the <code>application/mathml-presentation+xml</code> value for
   the <code class="attribute">encoding</code> attribute.  For backward compatibility with
   MathML 2.0, this case can also be represented with the equivalent
   <code>MathML-Presentation</code> value for the <code class="attribute">encoding</code>
   attribute.  Note that when a presentation MathML annotation is
   present in a <code class="element">semantics</code> element, it may be used as the
   default rendering of the <code class="element">semantics</code> element, instead of
   the default rendering of the first child.
   </p>

   <p>In the example below, the <code class="element">semantics</code> element binds together
   various alternate representations for a content MathML expression.
   The presentation MathML annotation may be used as the
   default rendering, while the other annotations give representations
   in other markup languages.  Since no attribution keys are explicitly
   specified, the default annotation key
   <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#alternate-representation">alternate-representation</a> applies
   to each of the annotations.
   </p>

   <!-- mml4c to prevent inlining -->
   <div class="example mathml mml4c">
     <pre>
       &lt;semantics&gt;
         &lt;apply&gt;
           &lt;plus/&gt;
           &lt;apply&gt;&lt;sin/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;/apply&gt;
           &lt;cn&gt;5&lt;/cn&gt;
         &lt;/apply&gt;
         &lt;annotation-xml encoding="MathML-Presentation"&gt;
           &lt;mrow&gt;
             &lt;mrow&gt;
               &lt;mi&gt;sin&lt;/mi&gt;
               &lt;mo&gt;&amp;#x2061;&lt;!--ApplyFunction--&gt;&lt;/mo&gt;
               &lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;
             &lt;/mrow&gt;
             &lt;mo&gt;+&lt;/mo&gt;
             &lt;mn&gt;5&lt;/mn&gt;
           &lt;/mrow&gt;
         &lt;/annotation-xml&gt;
         &lt;annotation encoding="application/x-maple"&gt;sin(x) + 5&lt;/annotation&gt;
         &lt;annotation encoding="application/vnd.wolfram.mathematica"&gt;Sin[x] + 5&lt;/annotation&gt;
         &lt;annotation encoding="application/x-tex"&gt;\sin x + 5&lt;/annotation&gt;
         &lt;annotation-xml encoding="application/openmath+xml"&gt;
           &lt;OMA xmlns="http://www.openmath.org/OpenMath"&gt;
             &lt;OMA&gt;
               &lt;OMS cd="arith1" name="plus"/&gt;
               &lt;OMA&gt;&lt;OMS cd="transc1" name="sin"/&gt;&lt;OMV name="x"/&gt;&lt;/OMA&gt;
               &lt;OMI&gt;5&lt;/OMI&gt;
             &lt;/OMA&gt;
           &lt;/OMA&gt;
         &lt;/annotation-xml&gt;
       &lt;/semantics&gt;
     </pre>
   </div>


   <p id="html-xml2">Note that this example makes use of the namespace extensibility
   that is only available in the XML syntax of MathML. If this example is included in
   an HTML document
   then it would be considered <em>invalid</em> and the OpenMath elements would be parsed as
   elements in the MathML namespace. See <a href="#html_annotation_xml"></a> for details.</p>
  </section>

  <section>
   <h4 id="mixing_content_equiv">Content equivalents</h4>

   <p>Content equivalent annotations provide additional computational
   information about an expression.  Annotations with the
   <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#contentequiv">contentequiv</a> key cannot be ignored
   without potentially changing the behavior of an expression.</p>

   <p>An important case arises when a content MathML annotation is used
   to disambiguate the meaning of a presentation MathML expression.
   This case may be represented by labeling the annotation with the
   <code>application/mathml-content+xml</code> value for the
   <code class="attribute">encoding</code> attribute.  In
   MathML 2, this type of annotation was represented with the equivalent
   <code>MathML-Content</code> value for the <code class="attribute">encoding</code> attribute,
   so processors are urged to support this usage for backward compatibility.
   The
   <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#contentequiv">contentequiv</a> annotation key should
   be used to make an explicit assertion that the annotation provides a
   definitive content markup equivalent for an expression.</p>

   <p>In the example below, an ambiguous presentation MathML expression
   is annotated with a <code>MathML-Content</code> annotation clarifying
   its precise meaning.</p>


   <!-- mml4c to prevent inlining -->
   <div class="example mathml mml4c">
     <pre>
       &lt;semantics&gt;
         &lt;mrow&gt;
           &lt;mrow&gt;
             &lt;mi&gt;a&lt;/mi&gt;
             &lt;mrow&gt;
               &lt;mo&gt;(&lt;/mo&gt;
               &lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;
               &lt;mo&gt;)&lt;/mo&gt;
             &lt;/mrow&gt;
           &lt;/mrow&gt;
         &lt;/mrow&gt;
         &lt;annotation-xml cd="mathmlkeys" name="contentequiv" encoding="MathML-Content"&gt;
           &lt;apply&gt;
             &lt;ci&gt;a&lt;/ci&gt;
             &lt;apply&gt;&lt;plus/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;cn&gt;5&lt;/cn&gt;&lt;/apply&gt;
           &lt;/apply&gt;
         &lt;/annotation-xml&gt;
       &lt;/semantics&gt;
     </pre>
   </div>

  </section>

  <section>
   <h4 id="mixing_annotation_references">Annotation references</h4>

   <p>In the usual case, each annotation element includes either character data
   content (in the case of <code class="element">annotation</code>) or XML markup data (in the case
   of <code class="element">annotation-xml</code>) that represents the <em>annotation value</em>.
   There is no restriction on the type of annotation that may appear within a
   <code class="element">semantics</code> element.  For example, an annotation could provide a
   TeX encoding, a linear input form for a computer algebra system,
   a rendered image, or detailed mathematical type information.</p>

   <p>In some cases the alternative children of a <code class="element">semantics</code> element
   are not an essential part of the behavior of the annotated expression, but
   may be useful to specialized processors.  To enable the availability of
   several annotation formats in a more efficient manner, a <code class="element">semantics</code>
   element may contain empty <code class="element">annotation</code> and <code class="element">annotation-xml</code>
   elements that provide <code class="attribute">encoding</code> and <code class="attribute">src</code> attributes
   to specify an external location for the annotation value associated with
   the annotation.  This type of annotation is known as an <em>annotation
   reference</em>.</p>


   <div class="example mathml-fragment">
     <pre>
       &lt;semantics&gt;
         &lt;mfrac&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;
         &lt;annotation encoding="image/png" src="333/formula56.png"/&gt;
         &lt;annotation encoding="application/x-maple" src="333/formula56.ms"/&gt;
       &lt;/semantics&gt;
     </pre>
   </div>


   <p>Processing agents that anticipate that consumers of exported markup may
   not be able to retrieve the external entity referenced by such annotations
   should request the content of the external entity at the indicated location
   and replace the annotation with its expanded form.</p>

   <p>An annotation reference follows the same rules as for other annotations
   to determine the annotation key that specifies the relationship between
   the annotated object and the annotation value.</p>

  </section>


  <section>
   <h4 id="mixing_elements_semantics">The <code class="defn starttag">&lt;semantics&gt;</code> element</h4>

   <section>
    <h5 id="mixing_semantics_description">Description</h5>

    <p>The <code class="element">semantics</code> element is the container element that
    associates annotations with a MathML expression.  The
    <code class="element">semantics</code> element has as its first child the expression to be
    annotated.  Any MathML expression may appear as the first child of the
    <code class="element">semantics</code> element.  Subsequent <code class="element">annotation</code> and
    <code class="element">annotation-xml</code> children enclose the annotations.
    An annotation represented in XML is enclosed in an
    <code class="element">annotation-xml</code> element.  An annotation represented
    in character data is enclosed in an <code class="element">annotation</code> element.</p>

    <p>As noted above, the <code class="element">semantics</code> element is considered to be
    both a presentation element and a content element, since it can act
    as either, depending on its content.  Consequently, all MathML
    processors should process the <code class="element">semantics</code> element, even if they
    process only presentation markup or only content markup.
    </p>

    <p>The default rendering of a <code class="element">semantics</code> element is the default
    rendering of its first child.  A renderer may use the information contained
    in the annotations to customize its rendering of the annotated element.</p>

    <div class="example mathml mmlcore">
      <pre>
        &lt;semantics&gt;
          &lt;mrow&gt;
            &lt;mrow&gt;
              &lt;mi&gt;sin&lt;/mi&gt;
              &lt;mo&gt;&amp;#x2061;&lt;!--ApplyFunction--&gt;&lt;/mo&gt;
              &lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;
            &lt;/mrow&gt;
            &lt;mo&gt;+&lt;/mo&gt;
            &lt;mn&gt;5&lt;/mn&gt;
          &lt;/mrow&gt;
          &lt;annotation-xml cd="mathmlkeys" name="contentequiv" encoding="MathML-Content"&gt;
            &lt;apply&gt;
              &lt;plus/&gt;
              &lt;apply&gt;&lt;sin/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;/apply&gt;
              &lt;cn&gt;5&lt;/cn&gt;
            &lt;/apply&gt;
          &lt;/annotation-xml&gt;
          &lt;annotation encoding="application/x-tex"&gt;\sin x + 5&lt;/annotation&gt;
        &lt;/semantics&gt;
      </pre>
    </div>

   </section>


  </section>

  <section>
   <h4 id="mixing_elements_annotation">The <code class="defn starttag">&lt;annotation&gt;</code> element</h4>

   <section>
    <h5 id="mixing_annotation_description">Description</h5>

    <p>The <code class="element">annotation</code> element is the container element for a semantic
    annotation whose representation is parsed character data in a non-XML
    format.  The <code class="element">annotation</code> element should contain the character
    data for the annotation, and should not contain XML markup elements.
    If the annotation contains one of the XML reserved characters
    <code>&amp;</code>, <code>&lt;</code> then these characters must
    be encoded using an entity reference or
    (in the XML syntax) an XML <code>CDATA</code> section.</p>

   </section>

   <section>
    <h5 id="mixing_annotation_attributes">Attributes</h5>

    <table class="data attributes">

     <thead>

      <tr>
       <td>Name</td>
       <td>values</td>
       <td>default</td>
      </tr>
     </thead>

     <tbody>

      <tr>
       <td rowspan="2" class="attname">definitionURL</td>
       <td><a class="intref" href="#type_uri"><em>URI</em></a></td>
       <td><em>none</em></td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The location of the annotation key symbol</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">encoding</td>
       <td><em>[=string=]</em></td>
       <td><em>none</em></td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The encoding of the semantic information in the annotation</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">cd</td>
       <td><em>[=string=]</em></td>
       <td>mathmlkeys</td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The content dictionary that contains the annotation key symbol</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">name</td>
       <td><em>[=string=]</em></td>
       <td>alternate-representation</td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The name of the annotation key symbol</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">src</td>
       <td><a class="intref" href="#type_uri"><em>URI</em></a></td>
       <td><em>none</em></td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The location of an external source for semantic information</td>
      </tr>
     </tbody>
    </table>

    <p>Taken together, the <code class="attribute">cd</code> and <code class="attribute">name</code> attributes
    specify the annotation key symbol, which identifies the relationship
    between the annotated element and the annotation, as described in
    <a href="#mixing_annotation_elements"></a>. The <code class="attribute">definitionURL</code>
    attribute provides an alternate way to reference the annotation key
    symbol as a single attribute.  If none of these attributes are present,
    the annotation key symbol is the symbol
    <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#alternate-representation">alternate-representation</a>
    from the <a class="omcd" href="https://openmath.org/cd/mathmlkeys">mathmlkeys</a> content dictionary.</p>

    <p>The <code class="attribute">encoding</code> attribute describes the content type of the
    annotation.  The value of the <code class="attribute">encoding</code> attribute may contain
    a media type that identifies the data format for the encoding data.  For
    data formats that do not have an associated media type, implementors may
    choose a self-describing character string to identify their content type.</p>

    <p>The <code class="attribute">src</code> attribute provides a mechanism to attach external
    entities as annotations on MathML expressions.</p>


    <div class="example mathml-fragment">
     <pre>
      &lt;annotation encoding="image/png" src="333/formula56.png"/&gt;
     </pre>
    </div>


    <p>The <code class="element">annotation</code> element is a semantic mapping element that may
    only be used as a child of the <code class="element">semantics</code> element.  While there is
    no default rendering for the <code class="element">annotation</code> element, a renderer may
    use the information contained in an annotation to customize its rendering
    of the annotated element.</p>

   </section>
  </section>

  <section>
   <h4 id="mixing_elements_annotation_xml">The <code class="defn starttag">&lt;annotation-xml&gt;</code> element</h4>

   <section>
    <h5 id="mixing_annotation_xml_description">Description</h5>

    <p>The <code class="element">annotation-xml</code> element is the container element for a
    semantic annotation whose representation is structured markup.  The <code class="element">annotation-xml</code> element should contain the markup
    elements, attributes, and character data for the annotation.</p>

   </section>

   <section>
    <h5 id="mixing_annotation_xml_attributes">Attributes</h5>

    <table class="data attributes">

     <thead>

      <tr>
       <td>Name</td>
       <td>values</td>
       <td>default</td>
      </tr>
     </thead>

     <tbody>

      <tr>
       <td rowspan="2" class="attname">definitionURL</td>
       <td><a class="intref" href="#type_uri"><em>URI</em></a></td>
       <td><em>none</em></td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The location of the annotation key symbol</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">encoding</td>
       <td><em>[=string=]</em></td>
       <td><em>none</em></td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The encoding of the semantic information in the annotation</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">cd</td>
       <td><em>[=string=]</em></td>
       <td>mathmlkeys</td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The content dictionary that contains the annotation key symbol</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">name</td>
       <td><em>[=string=]</em></td>
       <td>alternate-representation</td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The name of the annotation key symbol</td>
      </tr>

      <tr>
       <td rowspan="2" class="attname">src</td>
       <td><a class="intref" href="#type_uri"><em>URI</em></a></td>
       <td><em>none</em></td>
      </tr>

      <tr>
       <td colspan="2" class="attdesc">The location of an external source for semantic information</td>
      </tr>
     </tbody>
    </table>

    <p>Taken together, the <code class="attribute">cd</code> and <code class="attribute">name</code> attributes
    specify the annotation key symbol, which identifies the relationship
    between the annotated element and the annotation, as described in
    <a href="#mixing_annotation_elements"></a>. The <code class="attribute">definitionURL</code>
    attribute provides an alternate way to reference the annotation key
    symbol as a single attribute.  If none of these attributes are present,
    the annotation key symbol is the symbol
    <a class="omsymbol" href="https://openmath.org/cd/mathmlkeys#alternate-representation">alternate-representation</a>
    from the <a class="omcd" href="https://openmath.org/cd/mathmlkeys">mathmlkeys</a> content dictionary.</p>

    <p>The <code class="attribute">encoding</code> attribute describes the content type of the
    annotation.  The value of the <code class="attribute">encoding</code> attribute may contain
    a media type that identifies the data format for the encoding data.  For
    data formats that do not have an associated media type, implementors may
    choose a self-describing character string to identify their content type.
    In particular, as described above and in <a href="#encoding-names"></a>, MathML specifies
    <code>MathML</code>, <code>MathML-Presentation</code>, and
    <code>MathML-Content</code> as predefined values for the
    <code class="attribute">encoding</code> attribute.   Finally, the <code class="attribute">src</code>
    attribute provides a mechanism to attach external XML entities as
    annotations on MathML expressions.</p>


    <div class="example mathml-fragment">
      <pre>
        &lt;annotation-xml cd="mathmlkeys" name="contentequiv" encoding="MathML-Content"&gt;
          &lt;apply&gt;
            &lt;plus/&gt;
            &lt;apply&gt;&lt;sin/&gt;&lt;ci&gt;x&lt;/ci&gt;&lt;/apply&gt;
            &lt;cn&gt;5&lt;/cn&gt;
          &lt;/apply&gt;
        &lt;/annotation-xml&gt;

        &lt;annotation-xml encoding="application/openmath+xml"&gt;
          &lt;OMA xmlns="http://www.openmath.org/OpenMath"&gt;
            &lt;OMS cd="arith1" name="plus"/&gt;
            &lt;OMA&gt;&lt;OMS cd="transc1" name="sin"/&gt;&lt;OMV name="x"/&gt;&lt;/OMA&gt;
            &lt;OMI&gt;5&lt;/OMI&gt;
          &lt;/OMA&gt;
        &lt;/annotation-xml&gt;
      </pre>
    </div>


    <p>When the MathML is being parsed as XML and
    the annotation value is represented in an XML dialect other than MathML, the
    namespace for the XML markup for the annotation should be identified by means of namespace
    attributes and/or namespace prefixes on the annotation value.  For instance:</p>


    <div class="example mathml-fragment">
      <pre>
        &lt;annotation-xml encoding="application/xhtml+xml"&gt;
          &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
            &lt;head&gt;&lt;title&gt;E&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;
              &lt;p&gt;The base of the natural logarithms, approximately 2.71828.&lt;/p&gt;
            &lt;/body&gt;
          &lt;/html&gt;
        &lt;/annotation-xml&gt;
      </pre>
    </div>


    <p>The <code class="element">annotation-xml</code> element is a semantic mapping element that may only be used
    as a child of the <code class="element">semantics</code> element.  While there is no default rendering for the
    <code class="element">annotation-xml</code> element, a renderer may use the information contained in an
    annotation to customize its rendering of the annotated element.</p>

   </section>

   <section>
    <h5 id="html_annotation_xml">Using <code class="element">annotation-xml</code> in HTML documents</h5>

    <p>Note that the Namespace extensibility used in the above examples
    may not be available if the MathML is not being treated as an XML document. In particular
    HTML parsers
    treat <code>xmlns</code> attributes as ordinary attributes, so the OpenMath example would be classified as
    invalid
    by an HTML validator. The OpenMath elements would still be parsed as children of the
    <code class="element">annotation-xml</code> element, however they would be placed in the <em>MathML</em> namespace. The above examples are not rendered in the HTML version of this specification,
    to ensure that that document is a valid HTML5 document.</p>

    <p>The details of the HTML parser handling of <code class="element">annotation-xml</code> is specified in [[HTML]] and summarized in <a href="#interf_html"></a>, however the main differences from the behavior of an XML parser that affect MathML
    annotations are that the HTML parser does not treat <code>xmlns</code> attributes, nor <code>:</code> in element names as special and has built-in rules determining whether the three
    <q>known</q> namespaces, HTML, SVG or MathML are used.
    </p>
    <ul>

     <li>
      <p>If the <code class="element">annotation-xml</code> has an <code class="attribute">encoding</code> attribute that is (ignoring case differences) <code class="attributevalue">text/html</code> or <code class="attributevalue">annotation/xhtml+xml</code> then the content  is parsed as HTML and placed (initially) in the HTML namespace.</p>
     </li>

     <li>
      <p>Otherwise it is parsed as <em>foreign content</em> and parsed in a more XML-like manner (like MathML itself in HTML) in which <code>/&gt;</code> signifies an empty element. Content will be placed in the MathML namespace.</p>

      <p>If any recognised HTML element appears in this foreign content annotation the HTML
      parser will effectively terminate the math expression, closing all open elements until
      the <code class="element">math</code> element is closed, and then process the nested HTML as if it were not inside the
      math context. Any following MathML elements will then not render correctly as they
      are not in a math context, or in the MathML namespace.</p>
     </li>
    </ul>

    <p>These issues mean that the following example is valid whether parsed by an XML or
    HTML parser:</p>

    <div class="example mathml-fragment">
     <pre>
       &lt;math&gt;
         &lt;semantics&gt;
           &lt;mi&gt;a&lt;/mi&gt;
           &lt;annotation-xml encoding="text/html"&gt;
             &lt;span&gt;xxx&lt;/span&gt;
           &lt;/annotation-xml&gt;
         &lt;/semantics&gt;
         &lt;mo&gt;+&lt;/mo&gt;
         &lt;mi&gt;b&lt;/mi&gt;
       &lt;/math&gt;
     </pre>
    </div>

    <p> However if the <code class="attribute">encoding</code> attribute is omitted then the expression
    is only valid if parsed as XML:</p>

    <div class="example mathml-error">
     <pre>
       &lt;math&gt;
         &lt;semantics&gt;
           &lt;mi&gt;a&lt;/mi&gt;
           &lt;annotation-xml&gt;
             &lt;span&gt;xxx&lt;/span&gt;
           &lt;/annotation-xml&gt;
         &lt;/semantics&gt;
         &lt;mo&gt;+&lt;/mo&gt;
         &lt;mi&gt;b&lt;/mi&gt;
       &lt;/math&gt;
     </pre>
    </div>


    <p>If the above is parsed by an HTML parser it produces a result equivalent to the following
    invalid input, where the <code class="element" data-namespace="xhtml">span</code> element has caused all MathML elements to be prematurely closed. The remaining MathML
    elements following the <code class="element">span</code> are no longer contained within <code class="starttag">&lt;math&gt;</code> so will be parsed as unknown HTML elements and render incorrectly.</p>

    <div class="example mathml-error">
     <pre>
       &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;
         &lt;semantics&gt;
           &lt;mi&gt;a&lt;/mi&gt;
           &lt;annotation-xml&gt;
           &lt;/annotation-xml&gt;
         &lt;/semantics&gt;
       &lt;/math&gt;
       &lt;span xmlns="http://www.w3.org/1999/xhtml"&gt;xxx&lt;/span&gt;
       &lt;mo xmlns="http://www.w3.org/1999/xhtml"&gt;+&lt;/mo&gt;
       &lt;mi xmlns="http://www.w3.org/1999/xhtml"&gt;b&lt;/mi&gt;
     </pre>
    </div>


    <p>Note here that the HTML <code class="element" data-namespace="xhtml">span</code> element has
    caused all open MathML elements to be prematurely closed, resulting in
    the following MathML elements being treated as unknown HTML elements
    as they are no longer descendants of <code class="element">math</code>.
    See <a href="#interf_html"></a> for more details of the parsing of MathML in HTML.
    </p>

    <p>Any use of elements in other vocabularies (such as the OpenMath
    examples above) is considered <em>invalid</em> in HTML.  If
    validity is not a strict requirement it is possible to use such
    elements but they will be parsed as elements on the
    <em>MathML</em> namespace. Documents SHOULD NOT use namespace
    prefixes and element names containing colon (<code>:</code>) as the
    element nodes produced by the HTML parser have local names
    containing a colon, which can not be constructed by a namespace aware
    XML parser. Rather than use such foreign annotations, when using an HTML parser
    it is better to encode the annotation using the existing
    vocabulary. For example as shown in <a href="#contm"></a> OpenMath
    may be encoded faithfully as <em>Strict Content
    MathML</em>. Similarly RDF annotations could be encoded using RDFa
    in <code>text/html</code> annotation or (say) N3 notation in
    <code class="element">annotation</code> rather than using RDF/XML encoding in an
    <code class="element">annotation-xml</code> element.</p>

   </section>

  </section>



  <section>
   <h4 id="mixing_markup">Combining Presentation and Content Markup</h4>

   <p>
    Presentation markup encodes the <em>notational structure</em> of an expression.
    Content markup encodes the <em>functional structure</em> of an expression.  In certain
    cases, a particular application of MathML may require a combination of both presentation
    and content markup.  This section describes specific constraints that govern the use
    of presentation markup within content markup, and vice versa.
   </p>

   <section>
    <h5 id="mixing_pmincm">Presentation Markup in Content Markup</h5>

    <p>
     Presentation markup may be embedded within content markup so long as the
     resulting expression retains an unambiguous function application structure.
     Specifically, presentation markup may only appear in content markup
     in three ways:
    </p>
    <ol>

     <li>
      <p>within <code class="element">ci</code> and <code class="element">cn</code> token elements</p>
     </li>

     <li>
      <p>within the <code class="element">csymbol</code> element</p>
     </li>

     <li>
      <p>within the <code class="element">semantics</code> element</p>
     </li>
    </ol>

    <p>
     Any other presentation markup occurring within content markup is a
     MathML error.  More detailed discussion of these three cases follows:
    </p>
    <dl>

     <dt>Presentation markup within token elements.</dt>
     <dd>
      <p>The token elements <code class="element">ci</code> and <code class="element">cn</code> are permitted to
      contain any sequence of MathML characters (defined in <a href="#chars"></a>)
      and/or presentation elements.  Contiguous blocks of MathML characters in
      <code class="element">ci</code> or <code class="element">cn</code> elements are treated as if wrapped in
      <code class="element">mi</code> or <code class="element">mn</code> elements, as appropriate, and the resulting
      collection of presentation elements is rendered as if wrapped in an
      implicit <code class="element">mrow</code> element.</p>
     </dd>

     <dt>Presentation markup within the <code class="element">csymbol</code> element.</dt>
     <dd>
      <p>The same rendering rules that apply
      to the token elements <code class="element">ci</code> and <code class="element">cn</code> should be used for the <code class="element">csymbol</code> element.</p>
     </dd>

     <dt>Presentation markup within the <code class="element">semantics</code> element.</dt>
     <dd>
      <p>One of the main purposes of the <code class="element">semantics</code> element is to
      provide a mechanism for incorporating arbitrary MathML expressions into
      content markup in a semantically meaningful way.  In particular, any valid
      presentation expression can be embedded in a content expression by placing
      it as the first child of a <code class="element">semantics</code> element.  The meaning of this
      wrapped expression should be indicated by one or more annotation elements
      also contained in the <code class="element">semantics</code> element.</p>
     </dd>
    </dl>
   </section>

   <section>
    <h5 id="mixing_cminpm">Content Markup in Presentation Markup</h5>

    <p>
     Content markup may be embedded within presentation markup so long as the
     resulting expression has an unambiguous rendering.  That is, it must be
     possible, in principle, to produce a presentation markup fragment for
     each content markup fragment that appears in the combined expression.
     The replacement of each content markup fragment by its corresponding
     presentation markup should produce a well-formed presentation markup
     expression.  A presentation engine should then be able to process this
     presentation expression without reference to the content markup bits
     included in the original expression.
    </p>

    <p>
     In general, this constraint means that each embedded content expression
     must be well-formed, as a content expression, and must be able to stand
     alone outside the context of any containing content markup element.  As
     a result, the following content elements may not appear as an immediate
     child of a presentation element:
     <code class="element">annotation</code>, <code class="element">annotation-xml</code>,
     <code class="element">bvar</code>, <code class="element">condition</code>, <code class="element">degree</code>,
     <code class="element">logbase</code>, <code class="element">lowlimit</code>, <code class="element">uplimit</code>.
    </p>

    <p>
     In addition, within presentation markup, content markup may not appear
     within presentation token elements.
    </p>

   </section>

  </section>

  <section>
   <h4 id="mixing_parallel">Parallel Markup</h4>

   <p>
    Some applications are able to use <em>both</em> presentation
    and content information.  <em>Parallel markup</em> is a way to
    combine two or more markup trees for the same mathematical expression.
    Parallel markup is achieved with the <code class="element">semantics</code> element.
    Parallel markup for an expression may appear on its own, or as part
    of a larger content or presentation tree.
   </p>

   <section>
    <h5 id="mixing_top_level">Top-level Parallel Markup</h5>

    <p>
     In many cases, the goal is to provide presentation markup and content
     markup for a mathematical expression as a whole.
     A single <code class="element">semantics</code> element may be used to pair two markup trees,
     where one child element provides the presentation markup, and the
    other child element provides the content markup.</p>

    <p>
     The following example encodes the Boolean arithmetic expression
     <math alttext="(a+b)(c+d)" class="doc">
      <mrow><mo>(</mo><mi>a</mi> <mo>+</mo> <mi>b</mi><mo>)</mo></mrow>
      <mo>&#x2062;</mo>
      <mrow><mo>(</mo><mi>c</mi> <mo>+</mo> <mi>d</mi><mo>)</mo></mrow>
     </math>
     in this way.
    </p>

    <div class="example mathml mmlcore">
     <pre>
       &lt;semantics&gt;
         &lt;mrow&gt;
           &lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;
           &lt;mo&gt;&amp;#x2062;&lt;!--InvisibleTimes--&gt;&lt;/mo&gt;
           &lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;d&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;
         &lt;/mrow&gt;
         &lt;annotation-xml encoding="MathML-Content"&gt;
           &lt;apply&gt;&lt;and/&gt;
             &lt;apply&gt;&lt;xor/&gt;&lt;ci&gt;a&lt;/ci&gt; &lt;ci&gt;b&lt;/ci&gt;&lt;/apply&gt;
             &lt;apply&gt;&lt;xor/&gt;&lt;ci&gt;c&lt;/ci&gt; &lt;ci&gt;d&lt;/ci&gt;&lt;/apply&gt;
           &lt;/apply&gt;
         &lt;/annotation-xml&gt;
       &lt;/semantics&gt;
     </pre>
    </div>
    <p>
     Note that the above markup annotates the presentation markup as
     the first child element, with the content markup as part of the
     <code class="element">annotation-xml</code> element.  An equivalent form could be given
     that annotates the content markup as the first child element, with
     the presentation markup as part of the <code class="element">annotation-xml</code> element.
    </p>


   </section>

   <section>
    <h5 id="mixing_cr">Parallel Markup via Cross-References</h5>

    <p>
     To accommodate applications that must process sub-expressions of large
     objects, MathML supports cross-references between the branches of a
     <code class="element">semantics</code> element to identify corresponding sub-structures.
     These cross-references are established by the use of the <code class="attribute">id</code>
     and <code class="attribute">xref</code> attributes within a <code class="element">semantics</code> element.
     This application of the <code class="attribute">id</code> and <code class="attribute">xref</code> attributes within
     a <code class="element">semantics</code> element should be viewed as best practice to enable
     a recipient to select arbitrary sub-expressions in each alternative
     branch of a <code class="element">semantics</code> element.  The <code class="attribute">id</code> and
     <code class="attribute">xref</code> attributes may be placed on MathML elements of any type.
    </p>

    <p>
     The following example demonstrates cross-references for the
     Boolean arithmetic expression
     <math alttext="(a+b)(c+d)" class="doc">
      <mrow><mo>(</mo><mi>a</mi> <mo>+</mo> <mi>b</mi><mo>)</mo></mrow>
      <mo>&#x2062;</mo>
      <mrow><mo>(</mo><mi>c</mi> <mo>+</mo> <mi>d</mi><mo>)</mo></mrow>
      </math>.
    </p>

    <div class="example mathml mmlcore">
     <pre>
       &lt;semantics&gt;
         &lt;mrow id="E"&gt;
           &lt;mrow id="E.1"&gt;
             &lt;mo id="E.1.1"&gt;(&lt;/mo&gt;
             &lt;mi id="E.1.2"&gt;a&lt;/mi&gt;
             &lt;mo id="E.1.3"&gt;+&lt;/mo&gt;
             &lt;mi id="E.1.4"&gt;b&lt;/mi&gt;
             &lt;mo id="E.1.5"&gt;)&lt;/mo&gt;
           &lt;/mrow&gt;
           &lt;mo id="E.2"&gt;&amp;#x2062;&lt;!--InvisibleTimes--&gt;&lt;/mo&gt;
           &lt;mrow id="E.3"&gt;
             &lt;mo id="E.3.1"&gt;(&lt;/mo&gt;
             &lt;mi id="E.3.2"&gt;c&lt;/mi&gt;
             &lt;mo id="E.3.3"&gt;+&lt;/mo&gt;
             &lt;mi id="E.3.4"&gt;d&lt;/mi&gt;
             &lt;mo id="E.3.5"&gt;)&lt;/mo&gt;
           &lt;/mrow&gt;
         &lt;/mrow&gt;

         &lt;annotation-xml encoding="MathML-Content"&gt;
           &lt;apply xref="E"&gt;
             &lt;and xref="E.2"/&gt;
             &lt;apply xref="E.1"&gt;
               &lt;xor xref="E.1.3"/&gt;&lt;ci xref="E.1.2"&gt;a&lt;/ci&gt;&lt;ci xref="E.1.4"&gt;b&lt;/ci&gt;
             &lt;/apply&gt;
             &lt;apply xref="E.3"&gt;
               &lt;xor xref="E.3.3"/&gt;&lt;ci xref="E.3.2"&gt;c&lt;/ci&gt;&lt;ci xref="E.3.4"&gt;d&lt;/ci&gt;
             &lt;/apply&gt;
           &lt;/apply&gt;
         &lt;/annotation-xml&gt;
       &lt;/semantics&gt;
     </pre>
    </div>


    <p>
     An <code class="attribute">id</code> attribute and associated <code class="attribute">xref</code> attributes
     that appear within the same <code class="element">semantics</code> element establish the
     cross-references between corresponding sub-expressions.
    </p>

    <p>
     For parallel markup, all of the <code class="attribute">id</code> attributes referenced by any <code class="attribute">xref</code>
     attribute should be in the <em>same</em> branch of an enclosing
     <code class="element">semantics</code> element.  This constraint guarantees that the
     cross-references do not create unintentional cycles.  This restriction
     does <em>not</em> exclude the use of <code class="attribute">id</code> attributes within
     other branches of the enclosing <code class="element">semantics</code> element.  It does,
     however, exclude references to these other <code class="attribute">id</code> attributes
     originating from the same <code class="element">semantics</code> element.
    </p>

    <p>
     There is no restriction on which branch of the <code class="element">semantics</code> element
     may contain the destination <code class="attribute">id</code> attributes.  It is up to the
     application to determine which branch to use.
    </p>

    <p>
     In general, there will not be a one-to-one correspondence between nodes
     in parallel branches.  For example, a presentation tree may contain elements,
     such as parentheses, that have no correspondents in the content tree.  It is
     therefore often useful to put the <code class="attribute">id</code> attributes on the branch with
     the finest-grained node structure.  Then all of the other branches will have
     <code class="attribute">xref</code> attributes to some subset of the <code class="attribute">id</code> attributes.
    </p>

    <p>
     In absence of other criteria, the first branch of the <code class="element">semantics</code>
     element is a sensible choice to contain the <code class="attribute">id</code> attributes.
     Applications that add or remove annotations will then not have to re-assign
     these attributes as the annotations change.
    </p>

    <p>
     In general, the use of <code class="attribute">id</code> and <code class="attribute">xref</code> attributes allows
     a full correspondence between sub-expressions to be given in text that is
     at most a constant factor larger than the original.  The direction of the
     references should not be taken to imply that sub-expression selection is
     intended to be permitted only on one child of the <code class="element">semantics</code> element.
     It is equally feasible to select a subtree in any branch and
     to recover the corresponding subtrees of the other branches.
    </p>

    <p>
     Parallel markup with cross-references may be used in any
     of the semantic annotations within <code class="element">annotation-xml</code>,
     for example cross referencing between a presentation MathML rendering and an OpenMath annotation.
    </p>

    <p id="html-xml3">As noted above, the use of namespaces other than MathML, SVG
    or HTML within <code class="element">annotation-xml</code> is not considered valid in the HTML syntax.
    Use of colons and namespace-prefixed element names should be avoided
    as the HTML parser will generate nodes with <em>local</em> name <code>om:OMA</code>
    (for example), and such nodes can not be constructed by a namespace-aware XML parser.
    </p>

   </section>


  </section>
 </section>
</section>
